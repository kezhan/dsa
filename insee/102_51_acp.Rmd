---
title: "ACP des données démographiques"
always_allow_html: yes
---

```{r, child="_setup.Rmd"}
```

```{r, eval=F,include=F}
pacman::p_load(tidyverse,data.table,openxlsx,PCA)

```


https://programmathically.com/understanding-hinge-loss-and-the-svm-cost-function/


# Données


## import des données

Question:

- Utiliser `fread` pour importer les données
- Explorer les données avec les fonctions de base: `str`, `summary`

```{r}
data=read.xlsx("data/base_cc_comparateur.xlsx",startRow = 6)%>%data.table()
```


```{r}
# df <- read_excel("../data/insee/excel/base-cc-carac-emploi-2015.xls",sheet = "COM_2015",skip=5)

data_base=fread("data/base_cc_comparateur.csv",encoding = "UTF-8")

names(data)

```

Le descriptif des variables 


```{r}
var=fread("data/meta_base_cc_comparateur.csv",encoding = "UTF-8")

```


```{r}

data=var[COD_VAR=="CODGEO",c("COD_MOD","LIB_MOD")]%>%
  merge(data_base,by.x="COD_MOD",by.y="CODGEO")

```

## Filtres

```{r}
data=data[is.na(TP6019)==F]
data=data[P19_POP>1000 & P19_POP <500000]
data$densite_pop=data$P19_POP/data$SUPERF
```

```{r}
dput(names(data))

data_norm <- data %>% mutate_at(c("P19_POP", "P13_POP", "SUPERF", "NAIS1319", 
                                  "DECE1319", "P19_MEN", "NAISD21", "DECESD21", "P19_LOG", "P19_RP", 
                                  "P19_RSECOCC", "P19_LOGVAC", "P19_RP_PROP", "NBMENFISC19", "PIMP19", 
                                  "MED19", "TP6019", "P19_EMPLT", "P19_EMPLT_SAL", "P13_EMPLT", 
                                  "P19_POP1564", "P19_CHOMEUR1564", "P19_ACT1564", "ETTOT19", "ETAZ19", 
                                  "ETBE19", "ETFZ19", "ETGU19", "ETGZ19", "ETOQ19", "ETTEF119", 
                                  "ETTEFP1019", "densite_pop"), ~(scale(.) %>% as.vector))
```

## Exploration


```{r}
data[order(-P19_POP)]
data[order(P19_POP)]


data[order(ETTOT19)]
data[order(-ETTOT19)]

summary(data)

```

```{r}
data[is.na(TP6019)][order(-P19_POP)]

```


```{r}
data[order(densite_pop)]
hist(data$P19_POP,nclass=100)

hist(data$ETTOT19,nclass=100)

```


```{r}
# synthèse des filtres



```


## Nettoyage


```{r}
data[,c("ETAZ19", "ETBE19", "ETFZ19", "ETGU19", "ETGZ19", "ETOQ19", "ETTEF119", 
        "ETTEFP1019")]=data[,c("ETAZ19", 
                               "ETBE19", "ETFZ19", "ETGU19", "ETGZ19", "ETOQ19", "ETTEF119", 
                               "ETTEFP1019")]/data$ETTOT19


df=data[P19_POP>6000,c("CODGEO","LIBGEO","ETAZ19", "ETBE19", "ETFZ19", "ETGU19", "ETGZ19", "ETOQ19", "ETTEF119", 
        "ETTEFP1019")]


dfacp=df[,-c("LIBGEO","CODGEO")]
names(dfacp)=c("agriculture","industrie","construction","commerce","réparat auto","adm","PE","GE")

```

## Exploration

```{r}

hist(data$MED19)

```


```{r}
data$P19_RP

hist(data$P19_RP)

datatable(data)
```




# Comparaisons simples

## Cosine

```{r}
M <- as.matrix(data_norm[,-c("COD_MOD","LIB_MOD","SUPERF","P19_POP","P13_POP","SUPERF","P19_MEN")])
v <- as.vector(as.matrix(data_norm[COD_MOD=="92012",-c("COD_MOD","LIB_MOD","SUPERF","P19_POP","P13_POP","SUPERF","P19_MEN")]))

data$cosine=( M %*% v ) / sqrt( sum(v*v) * rowSums(M*M) )

data[order(cosine)]
data[order(-cosine)]

```

## Distance euclidienne

```{r}
dput(names(data))
```

```{r}



M <- as.matrix(data_norm[,c("ETTOT19", "ETAZ19", 
                            "ETBE19", "ETFZ19", "ETGU19", "ETGZ19", "ETOQ19", "ETTEF119", 
                            "ETTEFP1019", "densite_pop")])
v <- as.vector(as.matrix(data_norm[COD_MOD=="92012",c("ETTOT19", "ETAZ19", 
                            "ETBE19", "ETFZ19", "ETGU19", "ETGZ19", "ETOQ19", "ETTEF119", 
                            "ETTEFP1019", "densite_pop")]))

data$cosine=( M %*% v ) / sqrt( sum(v*v) * rowSums(M*M) )

data[order(cosine)]
data[order(-cosine)]


```


```{r}



data$distance=rowSums(sweep(M, 2, v)^2)
data[order(distance)]
data[order(-distance)]


```

### Autres


```{r}
# Boulogne Billancourt
ref=df[CODGEO=="92012"]

data$diff=rowSums((data[,c("ETAZ19", "ETBE19", "ETFZ19", "ETGU19", 
                      "ETGZ19", "ETOQ19", "ETTEF119", 
                      "ETTEFP1019")]-ref[rep(1,nrow(data)),c("ETAZ19", "ETBE19", "ETFZ19", "ETGU19", "ETGZ19", "ETOQ19", "ETTEF119", 
                                            "ETTEFP1019")])^2,na.rm = T)

data[P19_POP>1000 & diff>0,c("CODGEO","LIBGEO","diff")][order(diff)][1:10]%>%write.xlsx("output/diff_Boulogne.xlsx")


data[P19_POP>30000 & diff>0,][order(-diff)][1:10]%>%write.xlsx("output/Boulogne_très différents.xlsx")

```


```{r}
data[P19_POP>1000 & diff>0 & CODGEO %in% c("95018","92035","93066"),
     c("CODGEO","LIBGEO","diff")][order(diff)]%>%write.xlsx("output/Boulogne_compare.xlsx")
```


```{r}
code1="92049"
code2="95018"

diff=function(code1,code2){
  diff=rowSums((data[CODGEO==code1,c("ETAZ19", "ETBE19", "ETFZ19", "ETGU19", 
                      "ETGZ19", "ETOQ19", "ETTEF119", 
                      "ETTEFP1019")]-data[CODGEO==code2,c("ETAZ19", "ETBE19", "ETFZ19", "ETGU19", "ETGZ19", "ETOQ19", "ETTEF119", 
                                            "ETTEFP1019")])^2,na.rm = T)
  return(diff)
}

# argenteuil 95018
# montrouge 92049
diff("95018","92049")
data.table(CODGEO1=c("95018",""))


```

```{r}
# 92012 boulogne
# 92049 montrouge
diff("92012","92049")
```


```{r}
# 92035 la garenne colombe

diff("92012","92035")


```

# ACP

## Corrélation


Question

- Utiliser `cor` pour calculer la matrice de corrélation des différentes variables d'intérêt.
- Comprendre le message si la fonction retourne une erreur. voir le paramètre `use` dans l'aide.
- Choisir et tester les différentes possibilités pour `use`: `everything`, `all.obs`, `pairwise.complete.obs`.
- Tester plusieurs méthodes de calcul de corrélation.

```{r}

corrplot(cor(dfacp,use="pairwise.complete.obs"))

```



## Analyse en composante principales

L'analyse en composantes principales permet de construire des dimensions qui concentrent le maximum d'information.

Question: 

- Utiliser la fonction `PCA` pour réaliser l'ACP.
- Explorer les différents paramètres dans la fonction.

```{r, echo=FALSE}

ACP = PCA(dfacp, scale.unit = TRUE, graph = FALSE)


```


Questions:

- Visualiser les pourcentages des variances expliquées en fonction des composantes à l'aide de la fonction `fviz_eig()`

```{r}
fviz_eig(ACP)
```


## Projection des eaux du robinet sur l'espace des eaux minéraux {-}

```{r, echo=FALSE}
library(scatterD3)

affiche <- dfacp

affiche[,"X1"] <-  c(ACP$ind$coord[,1], ACP$ind.sup$coord[,1])
affiche[,"X2"] <-  c(ACP$ind$coord[,2], ACP$ind.sup$coord[,2])


affiche$Représentabilité <- c(ACP[["ind"]][["cos2"]][,1]+ ACP[["ind"]][["cos2"]][,2],
                              ACP$ind.sup$cos2[,1]+ACP$ind.sup$cos2[,2])
affiche$Nom  <- df$LIBGEO
affiche$Pop  <- df$P14_POP
```


```{r}
scatterD3(data = affiche, x = X1 , y = X2  , width = "100%" , 
          size_range = c(10,1000),
          opacity = Représentabilité, lab = Nom ,xlab = 'Dim1' ,ylab = 'Dim2', labels_size = 15)
```


```{r, echo=FALSE}
scatterD3(data = affiche[order(-Pop)][2:100,], x = X1 , y = X2  , width = "100%" , 
          size_var = Pop, 
          size_range = c(10,1000),
          opacity = Représentabilité, lab = Nom ,xlab = 'Dim1' ,ylab = 'Dim2', labels_size = 15)

```



```{r, echo=FALSE}
fviz_pca_var(ACP,
             col.var = "contrib", 
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE     
             )
```






